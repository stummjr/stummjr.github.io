<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>internals on Dunder Doc</title>
    <link>http://stummjr.github.io/tags/internals/</link>
    <description>Recent content in internals on Dunder Doc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 19 Sep 2021 23:19:13 -0300</lastBuildDate>
    
      <atom:link href="http://stummjr.github.io/tags/internals/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How Does CPython Multiply Big Numbers?</title>
      <link>http://stummjr.github.io/post/multiplication-in-cpython/</link>
      <pubDate>Sun, 19 Sep 2021 23:19:13 -0300</pubDate>
      
      <guid>http://stummjr.github.io/post/multiplication-in-cpython/</guid>
      <description>&lt;p&gt;I am used to write code that multiplies numbers several times a week. Usually when I do that, I don&amp;rsquo;t think much about the operation itself or how the machine will execute it.&lt;/p&gt;
&lt;p&gt;But if we start thinking about it, how in hell can the &lt;a href=&#34;https://github.com/python/cpython&#34;&gt;CPython&lt;/a&gt; interpreter multiply numbers as large as the ones below? The CPU definitely does not support huge numbers like that out of the box, so how does it work?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;92982374592874395723984756872342342234&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;670878370598623450872390483452435&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The answer is both simple and complex. ðŸ˜ƒ&lt;/p&gt;
&lt;p&gt;First of all, we have to acknowledge the fact that the numbers that we can represent in Python are way larger than the numbers that a modern CPU can. For example 10^100 is huuuuge but Python can handle it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To support that, CPython implements a long object (any integer number, basically) with an &lt;a href=&#34;https://github.com/python/cpython/blob/bb3e0c240bc60fe08d332ff5955d54197f79751c/Include/longintrepr.h#L85-L88&#34;&gt;array of digits&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I don&amp;rsquo;t know about you, but the first thing that comes to my mind when I think on how to multiply two numbers that are broken down digit by digit is to use that good old algorithm that we learn in grade school, creatively called &lt;a href=&#34;https://en.wikipedia.org/wiki/Multiplication_algorithm#Long_multiplication&#34;&gt;Grade-School Multiplication&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That is, given that I want to multiply 232 * 23, I can do something along these lines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  232
  *23
 ----
  696
+464
-----
 5336
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I am pretty sure you did that a bunch of times in your life and, believe it or not, CPython uses the very same multiplication algorithm &lt;em&gt;most of the time&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;diving-into-cpython-multiplication&#34;&gt;Diving Into CPython Multiplication&lt;/h2&gt;
&lt;p&gt;Before multiplying two numbers, CPython checks if at least one of the numbers is small enough to be handled efficiently with the grade-school algorithm.&lt;/p&gt;
&lt;p&gt;Simply put, CPython will use the grade-school algorithm (implemented in &lt;a href=&#34;https://github.com/python/cpython/blob/ef9e22b253253615098d22cb49141a2a1024ee3c/Objects/longobject.c#L3197&#34;&gt;&lt;code&gt;x_mul&lt;/code&gt;&lt;/a&gt;) to multiply two operands when at least one of these operands is less than 71 digits long (in &lt;strong&gt;base 2^30&lt;/strong&gt;), as we can see &lt;a href=&#34;https://github.com/python/cpython/blob/ef9e22b253253615098d22cb49141a2a1024ee3c/Objects/longobject.c#L3356-L3363&#34;&gt;here&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Use gradeschool math when either number is too small. */&lt;/span&gt;
i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; KARATSUBA_SQUARE_CUTOFF : KARATSUBA_CUTOFF;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (asize &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; i) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (asize &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (PyLongObject &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)PyLong_FromLong(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x_mul&lt;/span&gt;(a, b);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;base-230&#34;&gt;Base 2^30?&lt;/h3&gt;
&lt;p&gt;That&amp;rsquo;s right, CPython internally represents the numbers as an array of &lt;code&gt;uint32_t&lt;/code&gt;, where 30 out of 32 bits of each element are used for the actual value of that digit. And CPython will employ the grade-school algorithm when any of the operands have less than 71 base 2^30 digits.&lt;/p&gt;
&lt;p&gt;A 71 digits number, where each digit can represent up to 2^30-1, is quite a huge number! Think about it, a 71 &lt;strong&gt;decimal&lt;/strong&gt; digits number is a humongous number already, even though each digit can represent only up to 9. Now think about a number broken down in 71 parts, where each part can represent up to 1073741823.&lt;/p&gt;
&lt;h3 id=&#34;optimizations&#34;&gt;Optimizations&lt;/h3&gt;
&lt;p&gt;In order to be fast, CPython employs many optimizations for special cases. If you look at the snippet above, you will notice that if one of the numbers is zero, CPython doesn&amp;rsquo;t even try to multiply them and &lt;a href=&#34;https://github.com/python/cpython/blob/ef9e22b253253615098d22cb49141a2a1024ee3c/Objects/longobject.c#L3360&#34;&gt;returns 0 immediately&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;CPython also optimizes the multiplication of identical numbers (aka squaring) by using a separate algorithm for that case, as you can see in the &lt;a href=&#34;https://github.com/python/cpython/blob/ef9e22b253253615098d22cb49141a2a1024ee3c/Objects/longobject.c#L3209-L3252&#34;&gt;&lt;code&gt;x_mul&lt;/code&gt;&lt;/a&gt; function implementation.&lt;/p&gt;
&lt;h3 id=&#34;what-if-the-numbers-are-too-big&#34;&gt;What if the numbers are too big?&lt;/h3&gt;
&lt;p&gt;CPython defines &lt;code&gt;KARATSUBA_CUTOFF&lt;/code&gt; as 70 and the reason for the constant name is that in case both operands are too big (more than 70 digits long), CPython will employ the &lt;a href=&#34;https://en.wikipedia.org/wiki/Karatsuba_algorithm&#34;&gt;Karatsuba multiplication algorithm&lt;/a&gt; (implemented in &lt;a href=&#34;https://github.com/python/cpython/blob/ef9e22b253253615098d22cb49141a2a1024ee3c/Objects/longobject.c#L3322&#34;&gt;&lt;code&gt;k_mul&lt;/code&gt;&lt;/a&gt;), which is significantly faster than the traditional algorithm.&lt;/p&gt;
&lt;p&gt;Given that Karatsuba is a recursive algorithm, &lt;code&gt;k_mul&lt;/code&gt; recursively breaks the numbers in sub-parts and before multiplying them, it checks again if they are still big enough to use Karatsuba, otherwise it applies the grade-school algorithm. Now, I am not an expert on Karatsuba to explain it in any straightforward way, but &lt;a href=&#34;https://www.youtube.com/watch?v=JCbZayFr9RE&#34;&gt;this video&lt;/a&gt; is super helpful in case you want to understand it.&lt;/p&gt;
&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;This is not supposed to be a super deep dive into CPython, but I just wanted to show how fascinating it is to dive a tad bit on the stuff that we take for granted. Take multiplication for example: how often do we think that a simple multiplication in our program may actually be a O(N^2) operation? Even simpler operations, like adding two numbers, can be much more complex than we think when we use high level languages that support big numbers.&lt;/p&gt;
&lt;p&gt;And please don&amp;rsquo;t get me wrong, I really love the fact that I can easily multiply two huge numbers in Python without caring about overflows. However, it&amp;rsquo;s also great to know about what actually happens under the hood.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rushter.com/blog/python-integer-implementation/&#34;&gt;Python internals: Arbitrary-precision integer implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/python/cpython/blob/ef9e22b253253615098d22cb49141a2a1024ee3c/Objects/longobject.c&#34;&gt;longobject.c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CPython Optimizations</title>
      <link>http://stummjr.github.io/post/cpython-optimizations/</link>
      <pubDate>Fri, 19 Jun 2020 23:19:13 -0300</pubDate>
      
      <guid>http://stummjr.github.io/post/cpython-optimizations/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/python/cpython/&#34;&gt;CPython&lt;/a&gt; is the reference implementation of the Python language. While there are several other implementations, CPython is by far the most popular one. These days, it comes bundled in most of the operating systems.&lt;/p&gt;
&lt;p&gt;Even though CPython is not the most performatic Python interpreter out there, it does some very interesting optimizations to speed itself and Python programs up. I am pretty curious about things like these and the rationale behind them, even though I know very little about it. What follows is the result of some experimentation, myself reading CPython&amp;rsquo;s source code, documentation and blog posts.&lt;/p&gt;
&lt;p&gt;By no means this blog post is supposed to be a complete reference on optimizations done by CPython, but it can give you a hint on some of the ones that it does.&lt;/p&gt;
&lt;h2 id=&#34;caching-small-integers&#34;&gt;Caching Small Integers&lt;/h2&gt;
&lt;p&gt;CPython caches small integers from -5 to 256 in an internal array during its initialization. That means that every time the interpreter itself or your Python program needs to use a number in that range, CPython won&amp;rsquo;t have to allocate space and create a brand new object for that. It will just return a reference to a pre-existing object.&lt;/p&gt;
&lt;p&gt;Check this out:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
True
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are initially pointing to the exact same object because &lt;code&gt;-5&lt;/code&gt; is one of the small integers cached by CPython. With &lt;code&gt;-6&lt;/code&gt;, however, we have a different outcome. Now &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point to different objects, even though they have the very same value.&lt;/p&gt;
&lt;p&gt;As you can see, these singletons are used even when computing the result of arithmetic expressions:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CPython caches these small numbers because they are very often used in arithmetic operations, as boundaries in loops and as results of small computations. If CPython had to allocate memory and create a new object for each instance of these numbers, it would spend a bunch of time and space doing so.&lt;/p&gt;
&lt;h2 id=&#34;string-interning&#34;&gt;String Interning&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/String_interning&#34;&gt;String Interning&lt;/a&gt; is an optimization technique implemented by many modern compilers and interpreters. It consists of creating and storing only a single instance of a given string, rather than multiple. It makes a lot of sense, if you think about it, as strings are immutable objects in Python.&lt;/p&gt;
&lt;p&gt;In practical terms it means that some (not all, as we&amp;rsquo;ll see soon) strings will be &amp;ldquo;cached&amp;rdquo; by the Python interpreter. Here we can see that CPython creates a single string object to hold the &amp;ldquo;hey&amp;rdquo; string:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However, CPython does not intern each and every string. Check out how the strings below were not cached/interned:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey!&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey!&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That&amp;rsquo;s because CPython won&amp;rsquo;t intern strings that are not composed exclusively by ASCII letters, numbers or underscores (see &lt;a href=&#34;https://github.com/python/cpython/blob/314858e2763e76e77029ea0b691d749c32939087/Objects/codeobject.c#L24-L40&#34;&gt;codeobject.c&lt;/a&gt;). With this rule, CPython &amp;ldquo;ensures&amp;rdquo; that strings that look like valid Python identifiers will be interned. This way, function/method/variable names will end up interned and thus lookups will be faster during bytecode execution.&lt;/p&gt;
&lt;p&gt;Single-character strings will also be reused. CPython checks if the string has a single digit before allocating a new object. If it has, it will just return a reference to an already existing object that represents that character (see &lt;a href=&#34;https://github.com/python/cpython/blob/eb0d5c38de7f970d8cd8524f4163d831c7720f51/Objects/unicodeobject.c#L2321-L2338&#34;&gt;unicodeobject.c&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Ã¡&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Ã¡&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It&amp;rsquo;s not entirely clear to me in which cases exactly a string is interned. I&amp;rsquo;ve read conflicting information on the subject and my experiments yielded somewhat confusing results. (if you happen to know the answer, please drop a comment)&lt;/p&gt;
&lt;p&gt;One thing I can tell is that CPython does intern code-related strings such as variable names, function name and constants, &lt;a href=&#34;https://github.com/python/cpython/blob/3b3b83c965447a8329b34cb4befe6e9908880ee5/Objects/codeobject.c#L153-L167&#34;&gt;when creating code objects&lt;/a&gt;. Check this example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greet&lt;/span&gt;(x):
        msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; msg &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; x

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;greet&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; greet&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;__name__
True
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; code &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Bytecode(greet)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;codeobj
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; code&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;co_consts
(None, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; code&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;co_consts[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
True
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; code&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;co_varnames
(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;msg&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; code&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;co_varnames[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The snippet above demonstrates that string constants, function name and variable names have been interned when CPython creates the code object (that is, when it creates the code object that will represent the function).&lt;/p&gt;
&lt;h3 id=&#34;forcing-cpython-to-intern-a-string&#34;&gt;Forcing CPython to Intern a String&lt;/h3&gt;
&lt;p&gt;If, for some reason, you want to force CPython to intern a given string, you can call the &lt;a href=&#34;https://docs.python.org/3/library/sys.html#sys.intern&#34;&gt;&lt;code&gt;sys.intern&lt;/code&gt;&lt;/a&gt; function passing a string as its argument. This may be helpful if you have huge strings that you&amp;rsquo;ll need to reuse often and that would not be automatically interned by CPython. For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey!&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey!&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
False
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;intern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey!&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;intern(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey!&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; y
True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Another advantage is that interned strings can be compared using pointer comparison, rather than char by char.&lt;/p&gt;
&lt;h2 id=&#34;constant-folding&#34;&gt;Constant Folding&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Constant_folding&#34;&gt;Constant folding&lt;/a&gt; is another technique often employed by compilers and interpreters. It consists of precomputing in compile time the expressions that have no runtime dependencies. For example, it is quite common to find definitions like this in Python programs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;kilobyte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;People usually do that so that other people reading their code can get a better grasp on how an otherwise &amp;ldquo;magic&amp;rdquo; value (8192 in this case) was actually defined.&lt;/p&gt;
&lt;p&gt;The CPython interpreter folds that expression into a constant while compiling the source code (&lt;code&gt;.py&lt;/code&gt;) into bytecode (&lt;code&gt;.pyc&lt;/code&gt;). In practical terms, it means that the resulting bytecode won&amp;rsquo;t contain the &lt;code&gt;8 * 1024&lt;/code&gt; expression, but the &lt;code&gt;8192&lt;/code&gt; constant instead. We are basically trading run time for compile time. Imagine if &lt;code&gt;kilobyte&lt;/code&gt; was defined in a function that is called thousands of times during a program execution. We&amp;rsquo;d have thousands of multiplications, all happening in runtime.&lt;/p&gt;
&lt;h3 id=&#34;digging-a-bit-more&#34;&gt;Digging a Bit More&lt;/h3&gt;
&lt;p&gt;Before we start digging, let me show you how we can verify if a given expression is being folded into a constant or not. An easy way to do that is to use the &lt;a href=&#34;https://docs.python.org/3/library/dis.html&#34;&gt;&lt;code&gt;dis&lt;/code&gt;&lt;/a&gt; module to disassemble a Python function into its bytecode representation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; dis
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;():
        kilobyte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis(func)
  &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;8192&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; STORE_FAST               &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (kilobyte)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (None)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see in the bytecode output of the &lt;code&gt;dis&lt;/code&gt; call above, there&amp;rsquo;s no multiplication instruction and we have &lt;code&gt;8192&lt;/code&gt; as a constant value instead. That means that CPython precomputed that expression and created a constant for its value in compile-time, so that when the bytecode runs no multiplication has to be made.&lt;/p&gt;
&lt;h3 id=&#34;strings-can-be-folded&#34;&gt;Strings Can Be Folded&lt;/h3&gt;
&lt;p&gt;Constant folding is not used exclusively for arithmetic expressions. Expressions that compute strings are also candidates for that optimization. Check this out:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;():
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis(func)
  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;----------&amp;#39;&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See how the bytecode contains the computed version of the string already. Not all string operations will be folded, though:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;():
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis(func)
  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; BINARY_MULTIPLY
              &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see in the bytecode above, we have a &lt;code&gt;BINARY_MULTIPLY&lt;/code&gt; instruction that will take place in runtime.&lt;/p&gt;
&lt;h3 id=&#34;large-strings-wont-be-folded&#34;&gt;Large Strings Won&amp;rsquo;t Be Folded&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; these experiments were done using CPython 3.7.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;My first hypothesis when I saw the output above was that it was something related to the string size. It makes a ton of sense for CPython to not expand expressions like &lt;code&gt;&#39;-&#39; * 10000000&lt;/code&gt; into constants, as that would generate bigger &lt;code&gt;.pyc&lt;/code&gt; files. But I got curious on what&amp;rsquo;s CPython threshold for that.&lt;/p&gt;
&lt;p&gt;To find that out, I wrote a quick and dirty function to check if a given expression would be folded or not:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;folds&lt;/span&gt;(string, size):
    c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; compile(f&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#39;{string}&amp;#39; * {size}&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dummyfile&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;eval&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#75715e&#34;&gt;# in case the constant has not been folded, `co_consts` will be (string, size)&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# in case it was folded, it will be represented by a tuple with the resulting string&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;co_consts[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; string
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That function allowed me to find out that &lt;strong&gt;CPython&amp;gt;=3.7 won&amp;rsquo;t fold strings bigger than 4096 characters into constants&lt;/strong&gt;. Check this out:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; folds(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt;)
True
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; folds(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4097&lt;/span&gt;)
False
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; folds(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;--&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2048&lt;/span&gt;)
True
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; folds(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;--&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2049&lt;/span&gt;)
False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;P.S.:&lt;/strong&gt; CPython versions prior to 3.7 have a way smaller limit set to 20 chars.&lt;/p&gt;
&lt;h3 id=&#34;tuples-are-folded-as-well&#34;&gt;Tuples Are Folded As Well&lt;/h3&gt;
&lt;p&gt;As strings and numbers, tuples are also immutable objects in Python. So, tuples will also be folded in constants, as the experiment below shows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;():
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis(func)
  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; ((&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;))
              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;what-about-constant-propagation&#34;&gt;What About Constant Propagation?&lt;/h3&gt;
&lt;p&gt;As far as I can tell, CPython &lt;strong&gt;does not do&lt;/strong&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Constant_folding#Constant_propagation&#34;&gt;Constant Propagation&lt;/a&gt;. That is, it does not replace variables whose values are known in compile time by their actual values. Check this out:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;():
        kilobyte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8192&lt;/span&gt;
        megabyte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kilobyte &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis(func)
  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;8192&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; STORE_FAST               &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (kilobyte)

  &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; LOAD_FAST                &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (kilobyte)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; BINARY_MULTIPLY
             &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; STORE_FAST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (megabyte)
             &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (None)
             &lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt; RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If CPython did it, it would propagate the &lt;code&gt;kilobyte&lt;/code&gt; value into the expression that uses it and it would be able to fold the whole expression into a constant. There would be no need for a &lt;code&gt;BINARY_MULTIPLY&lt;/code&gt; instruction in the resulting bytecode in that case.&lt;/p&gt;
&lt;h2 id=&#34;dead-code-elimination&#34;&gt;Dead Code Elimination&lt;/h2&gt;
&lt;p&gt;CPython also eliminates dead code, such as unreachable statements. In the example below, the first &lt;code&gt;print&lt;/code&gt; will never be reached, so no bytecode is generated for that branch:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;():
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; False:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;)
      &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hey!&amp;#34;&lt;/span&gt;)

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis(func)
  &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; LOAD_GLOBAL              &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey!&amp;#39;&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; CALL_FUNCTION            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
              &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; POP_TOP
              &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (None)
             &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Any code added after a &lt;code&gt;return&lt;/code&gt; statement will also be eliminated:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;():
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hey&amp;#34;&lt;/span&gt;
        s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;what am I doing here?&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; dis&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dis(func)
  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; LOAD_CONST               &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hey&amp;#39;&lt;/span&gt;)
              &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;Keep in mind that the optimizations listed in this blog post are specific to the CPython interpreter. Other interpreters like PyPy employ additional techniques to speed themselves up, but they were not covered in this blog post.&lt;/p&gt;
&lt;p&gt;Optimizations like these are not part of the language specification, obviously. Each interpreter is free to implement as many optimizations as they want, as long as the semantics stays the same. One important takeaway is that the correctness of your code should never rely on any of these optimizations, as they are implementation details and could be dropped any time.&lt;/p&gt;
&lt;h3 id=&#34;read-more&#34;&gt;Read More&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://guilload.com/python-string-interning/&#34;&gt;The Internals of Python String Interning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://arpitbhayani.me/blogs/python-caches-integers&#34;&gt;Python Caches Integers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/a/24245514/1084647&#34;&gt;Martijn Pieters&amp;rsquo; answer on Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
